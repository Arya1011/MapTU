<!DOCTYPE html><html><head><meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1"><title>thapMapsREADME.md</title><script type="text/javascript">
    //<![CDATA[
    window.__cfRocketOptions = {byc:0,p:0,petok:"195e545e2157f6ee01ada7aaea605a95ae994100-1525615924-1800"};
    //]]>
    </script>
    <script type="text/javascript" src="https://ajax.cloudflare.com/cdn-cgi/scripts/935cb224/cloudflare-static/rocket.min.js"></script>
    <style>
    h1 a , blockquote {
      padding-left: 18px;
    }
    h2 a {
      padding-left: 24px;
    }
    </style>
    <h1><a id="thapMaps_0"></a>thapMaps</h1>
    <blockquote>
    <p>A <a href="http://leafletjs.com">Leaflet.js</a> based maps-clone that implements shortest route finding on a map of the college campus and renders requisite polylines</p>
    </blockquote>
    <h2><a id="Front_End_4"></a>Front End</h2>
    <ul>
    <li><a href="http://leafletjs.com">Leaflet.js</a><br>
    Rendering a map of the college campus using Leaflet.js’ support for creating <a href="https://openstreetmap.org">OpenStreetMap</a> tiles by simply passing the coordinates required</li>
    <li>
    <h5><a id="Data_7"></a>Data</h5>
    73 nodes manually added into a Javascript locations array, each node structured like so:<pre><code class="language-javascript"><span class="hljs-keyword">var</span> locations = [
    { <span class="hljs-string">"name"</span> : <span class="hljs-string">"Entrance Intersection"</span>, <span class="hljs-string">"x"</span> :  <span class="hljs-number">30.351946</span>, <span class="hljs-string">"y"</span> : <span class="hljs-number">76.372913</span>,
    <span class="hljs-string">"children"</span> : [<span class="hljs-string">"Car Parking"</span>, <span class="hljs-string">"Audi-Cafeteria Intersection"</span>]},
    ...
    ]
    </code></pre>
    where the <code>children</code> array holds the <code>name</code> property of each node which can be linked to that node by a straight line path.</li>
    </ul>
    <h2><a id="The_Algorithm_18"></a>The Algorithm</h2>
    <ul>
    <li>The <a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman Ford</a> algorithm is a famous algorithm based on dynamic programming techniques to get the shortest path between any two nodes of a graph. The algorithm is suitable because of its applicability to graphs containing cycles - such as a graph of real world locations.</li>
    <li>One advantage that we have here is of no negative edge weights, which eliminates the possibility of the existence of negative cycles.</li>
    <li>The most crucial observation behind the algorithm is that for a graph with <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span> vertices, and no negative cycles - or a cycle with net negative cost - there is a shortest path between vertex <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span></span> and <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span></span>, or <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(s,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span></span>, that does not repeat any edges and hence has a at most <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">n</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span> edges.</li>
    <li>The algorithm thus iterates <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">n</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span> times, each iteration signifying the maximum number of edges that may be used by each node to get to the destination for that iteration. For each node, in each iteration, the following recurrence is applied :<br>
    <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mrow><mo fence="true">{</mo><mrow><mi>M</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><msub><mi>min</mi><mo>⁡</mo><mrow><mi>w</mi><mo>∈</mo><mi>V</mi></mrow></msub><mrow><mo fence="true">{</mo><mrow><msub><mi>C</mi><mrow><mi>w</mi><mi>v</mi></mrow></msub><mo>+</mo><mi>M</mi><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo fence="true">}</mo></mrow></mrow><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">M[v] = \min\left\{{M[v], \min\limits_{w \in V} \left\{{C_{wv} + M[w]}\right\}}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.45em;"></span><span class="strut bottom" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop">min</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.055669em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">∈</span><span class="mord mathit mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.771701em;"></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.02691em;">w</span><span class="mord mathit mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span></span></span></span></span><br>
    where :
    <ul>
    <li><span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span></span> : Set of all vertices of the graph</li>
    <li><span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">M[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span></span> : Array containing the currently found shortest paths for each vertex</li>
    <li><span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span></span>: Weight of the edge between vertices <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span></span> and <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span></span></li>
    </ul>
    </li>
    <li>To get the nodes comprising the shortest path, an addition is made to the algorithm by storing a reference to the first neighbouring node in the shortest path to the destination for each node <span class="math inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span></span> in a separate array, and iterating over that array starting from the source, like so:<pre><code class="language-javascript"><span class="hljs-keyword">var</span> j = source; <span class="hljs-comment">// Get the route-array starting at source, to dest</span>
    <span class="hljs-keyword">do</span> {
    route.push(nodes[j]);
    j = nodes[j];
    } <span class="hljs-keyword">while</span>(j != dest)
    </code></pre>
    where <code>nodes</code> is the array containing the references, as mentioned above.</li>
    <li>The implementation of the algorithm in Javascript for a distance matrix based approach is encapsulated within the <code>bellmanFord()</code> function.</li>
    </ul>
    <h2><a id="Lighthouse_Audit_39"></a>Lighthouse Audit</h2>
    <p><img src="https://i.imgur.com/Ybiib8b.png" alt="Light House Audit"></p>
    <h2><a id="Possible_Enhancements_42"></a>Possible Enhancements</h2>
    <ul>
    <li>
    <p><strong>Navigation</strong><br>
    Storing the children for each node in a direction-agnostic way has made the application unable to provide directions in a Google Maps format. However, simple naviational steps, like, providing each leg of the route and its distance, is a feature that may be added in an extension of this project.</p>
    </li>
    <li>
    <p><strong>Multiple Destinations</strong><br>
    A simple extension to the project would be to allow for multiple destinations and render the appropriate polyline, ensuring that the shortest path is rendered despite the restrictions.</p>
    </li>
    <li>
    <p><strong>Progressive Web Application</strong><br>
    Lighthouse has penalised the application for not registering a service worker, not providing for a custom splash screen, header bar not matching brand colours, and not including a prompt to ‘Add to Home Screen’.</p>
    </li>
    </ul>
    <h2><a id="Sources_of_error_52"></a>Sources of error</h2>
    <ul>
    <li>Although care has been taken to carefully test, if for a particular set of source and destination points, the page crashes and causes the browser’s memory error page to load, that is due to errant manual entry of nodes in the <code>children</code> array of each node, causing that particular pair of points to become unreachable on the virtual graph. If you have encountered such an error, please <a href="/cdn-cgi/l/email-protection#02606963716a7b63725d6067333442766a637263702c676677">inform</a> the maintainer of the project.</li>
    </ul>
    
    <script data-cfasync="false" src="/cdn-cgi/scripts/d07b1474/cloudflare-static/email-decode.min.js"></script></body></html>